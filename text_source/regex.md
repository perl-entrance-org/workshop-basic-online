# 正規表現

---

## データ処理に最適な「正規表現」

正規表現という語を聞いたことはありますでしょうか？正規表現を利用することで

- 文字列が「複雑な条件」に合致しているかテストする

- 「複雑な条件」に合致した文字列を検索する

- 「複雑な条件」に合致した文字列を置き換える・削除する

といったことが可能になります。

---

## 複雑な条件とは

ここでいう「複雑な条件」とは例えば以下のようなものです。

- p で始まり <ruby>l<rt>エル</rt></ruby> で終わる 4 文字

- 特定の文字を「含まない」

- 2021-09-25 といった、4桁の数字, ハイフン, 2桁の数字, ハイフン, 2桁の数字を連結したもの

- 行頭に「メロス」が存在する行のみ

---

## Perl と正規表現

Perl は他のプログラミング言語と比べて正規表現が書きやすい言語です。

また、Perl の記述法を利用して正規表現機能を提供しているソフトもあり、これらで提供している正規表現は PCRE(Perl Compatible Regular Expressions) と呼ばれています。

Perl の正規表現でデータを取得、きれいに整形した後で他のプログラムで利用する、というように、組み合わせて利用されることも多い機能です。

---

## Perl と正規表現

正規表現は奥が深く、またそれだけで専門の分野がある広大な学問分野です。

Perl の正規表現は、それ自体が小さなプログラミング言語と思えるほどの機能を有しています。

Perl 入学式のみで全て紹介することはできませんが、コードを書く上でよく利用する「基本的な部分」を紹介していきます。

---

## 正規表現の用語について

まず、正規表現の用語を簡単に解説します。

- **メタ文字**

    文字そのものを表さない、特殊な意味を持つ正規表現内の文字。

- **マッチする**

    対象の文字列を、正規表現で表せること。

具体性が欠けるのでイメージしづらいと思うのですが、このあと実践して学習していきます。

まずはメタ文字です。

---

## 文字を表す文字、メタ文字（1/3）

| メタ文字 | 説明 |
| - | - |
| . | 任意の 1 文字にマッチする |
| [■] | 文字クラス。リスト ■ の中にある任意の 1 文字にマッチする
| [^■] | 否定の文字クラス。リスト ■ の中にない任意の 1 文字にマッチする
| ●? | 正規表現 ● が 0 個もしくは 1 個存在する
| ●* | 正規表現 ● が 0 個もしくは 1 個以上存在する
| ●+ | 正規表現 ● が 1 個以上存在する

聞き慣れない用語の次に、今度は記号がたくさん出てきましたした。これから順に説明していきます。

---

## 正規表現でテストする

文字列の比較には比較演算子 `eq` を利用しました。

```perl
if ('perl' eq 'p..l'){
    print "match" . "\n";
}else{
    print "no match" . "\n";    # こちらが表示される
}
```

しかし、文字列の比較では「p ではじまり <ruby>l<rt>エル</rt></ruby> で終わる 4 文字の単語」という検索はできません。

---

## 正規表現でテストする

「p ではじまり <ruby>l<rt>エル</rt></ruby> で終わる 4 文字の単語」といった<ruby>曖昧<rt>あいまい</rt></ruby>な条件に合致するかをテストをするために、正規表現を利用します。

正規表現を利用してテストするときは、専用の演算子を利用します。

`=~` の左辺に比較したい文字列、右辺に正規表現を `//` で囲って記述します。

以下は `perl` という文字列が <ruby>`p..l`<rt>ピー ドット ドット エル</rt></ruby> という正規表現にマッチするかをテストするプログラムです。

```perl
if ('perl' =~ /p..l/){
    print "match" . "\n";   # こちらが表示される
}else{
    print "no match" . "\n";
}
```

---

## メタ文字 `.` （ドット）

正規表現中で使われている `.` （ドット）は「任意の1文字」を表します。

```perl
if ('perl' =~ /p..l/){
    print "match" . "\n";   # こちらが表示される
}else{
    print "no match" . "\n";
}
```

```perl
if ('pel' =~ /p..l/){
    print "match" . "\n";
}else{
    print "no match" . "\n";    # こちらが表示される
}
```

```perl
if ('perrl' =~ /p..l/){
    print "match" . "\n";
}else{
    print "no match" . "\n";    # こちらが表示される
}
```

---

## メタ文字 `[■]` 文字クラス

`[ ]`で囲まれた文字は **文字クラス** と言います。■ は文字の集合を表したものです。

たとえば `[abcde]` は `a` 又は `b` 又は `c` 又は `d` 又は `e` いずれか 1 文字とマッチします。

```perl
if ('perl' =~ /p[abcde]rl/){
    print "match" . "\n";   # こちらが表示される
}else{
    print "no match" . "\n";
}
```

```perl
if ('perl' =~ /p[abcd]rl/){
    print "match" . "\n";
}else{
    print "no match" . "\n";    # こちらが表示される
}
```

---

## メタ文字 `[■]` 文字クラス

連続した文字であれば、`[a-e]`のように書くことも可能です。

```perl
if ('perl' =~ /p[a-e]rl/){
    print "match" . "\n";   # こちらが表示される
}else{
    print "no match" . "\n";
}
```

---

## メタ文字 `[^■]` 否定の文字クラス

文字クラスの `[]` 内の先頭に <ruby>`^`<rt>キャレット</rt></ruby> を書くと、否定の文字クラスとなります。**文字クラスに書かれているもの以外の 1 文字** にマッチします。

```perl
if ('perl' =~ /p[^xyz]rl/){
    print "match" . "\n";    # こちらが表示される
}else{
    print "no match" . "\n";
}
```

```perl
if ('perl' =~ /p[^f-z]rl/){
    print "match" . "\n";   # こちらが表示される
}else{
    print "no match" . "\n";
}
```

```perl
if ('perl' =~ /p[^abcde]rl/){
    print "match" . "\n";
}else{
    print "no match" . "\n";    # こちらが表示される
}
```

---

## メタ文字 `●?` 直前の正規表現が 0 個もしくは 1 個存在する

いままでは `.` や `[a-e]` など 1 文字にマッチする正規表現を学んできました。ここからは複数の文字にマッチする正規表現を学んでいきます。

● は先に学習した任意の1文字を表す `.` や 文字クラス `[ ]` を表すものとみてください。

この `?` は **その直前の正規表現 ● が 0 個もしくは 1 個存在する時** にマッチします。

```perl
if ('perl' =~ /p.?rl/){
    print "match" . "\n";   # こちらが表示される
}else{
    print "no match" . "\n";
}
```

---

## メタ文字 `●?` 直前の正規表現が 0 個もしくは 1 個存在する

0 個というのは `●` が存在しない時もマッチするという意味になります。

```perl
if ('prl' =~ /p.?rl/){
    print "match" . "\n";   # こちらが表示される
}else{
    print "no match" . "\n";
}
```

---

## メタ文字 `●*` 直前の正規表現が 0 個もしくは 1 個以上存在する

先程の `?` は「その直前の正規表現 ● が 0 個もしくは 1 個存在する時」でした。ここで紹介する `*` は **その直前の正規表現 ● が 0 個または 1 個以上存在する時** にマッチします。

0 個のとき

```perl
if ('prl' =~ /p.*rl/){
    print "match" . "\n";   # こちらが表示される
}else{
    print "no match" . "\n";
}
```

---

## メタ文字 `●*` 直前の正規表現が 0 個もしくは 1 個以上存在する

1 個のとき

```perl
if ('perl' =~ /p.*rl/){
    print "match" . "\n";   # こちらが表示される
}else{
    print "no match" . "\n";
}
```

1 個以上の時
```perl
if ('perl girl' =~ /p.*rl/){
    print "match" . "\n";   # こちらが表示される
}else{
    print "no match" . "\n";
}
```

---

## メタ文字 `●+` 直前の正規表現が 1 個以上存在する

`+` は **その直前の正規表現 ●が 1 個以上存在する時** にマッチします。

```perl
if ('perl' =~ /p.+rl/){
    print "match" . "\n";   # こちらが表示される
}else{
    print "no match" . "\n";
}
```

```perl
if ('prl' =~ /p.+rl/){
    print "match" . "\n";
}else{
    print "no match" . "\n";    # こちらが表示される
}
```

---

## 練習問題

1. 正規表現 `p.l` に合致する文字列をすべて選んでください

    1. perl
    2. pl
    3. pal

1. 正規表現 `p.*l` に合致する文字列をすべて選んでください

    1. perl
    2. pl
    3. pal

1. 正規表現 `p.+l` に合致する文字列をすべて選んでください

    1. perl
    2. pl
    3. pal


---

## 練習問題

1. 正規表現 `[perl]?` に合致する文字列をすべて選んでください

    1. go
    1. perl
    1. ruby

1. 正規表現 `[perl]*` に合致する文字列をすべて選んでください

    1. go
    1. perl
    1. ruby

1. 正規表現 `[perl]+` に合致する文字列をすべて選んでください

    1. go
    1. perl
    1. ruby

---

## 文字を表す文字、メタ文字（2/3）

| メタ文字 | 説明 |
| - | - |
| (●) | グループを作る。正規表現 ● にマッチした場合、キャプチャを行う
| (?:●) | グループを作るが、キャプチャは行わない
| ●*? | ●* と同じ意味だが、マッチパターンが複数ある場合、 ●* はなるべく長くマッチするのに対し、 ●*? はなるべく短くマッチする
| ●\|◎ | 左右の正規表現 ●◎ のどちらかにマッチする


---

## `(●)` でグループを作ってキャプチャする

正規表現 ● を `()` で囲むことで、マッチした文字列を取得することができます。これを **キャプチャ** と呼びます。

キャプチャされた文字列は `$1` という特殊変数に格納されます。この `$1` は `my` で宣言せずに利用します。

```perl
if ('perl girl' =~ /(p..l)/){
    print $1 . "\n";    # perl girl
}else{
    print "no match" . "\n";
}
```

---

## `(●)` でグループを作ってキャプチャする

複数キャプチャすることも可能で、そのときはマッチした文字列が $1, $2 ... と順番に変数に格納されます。


複数キャプチャする時はこのようになります。

```perl
if ('perl girl' =~ /(p..l) (g..l)/){
    print $1 . "\n";    # perl
    print $2 . "\n";    # girl
}else{
    print "no match" . "\n";
}
```

---

## `(?:●)` でグループを作るがキャプチャしない

取得したい文字列が決まっているが、それとは別にグループだけしておきたいという場面が出てきます。

例えば以下の例で `girl` だけ取得したい場合、2 回キャプチャして 2 回目のみを利用するだけでも用は足ります。

しかし、利用されなかった `$1` はどこかで利用する？という疑問がプログラム上に残ります。

```perl
if ('perl girl' =~ /(p..l) (g..l)/){
    # $2 だけでも目的は果たせるが、$1 はどこかで利用する？という疑問が残る
    print $2 . "\n";    # girl
}else{
    print "no match" . "\n";
}
```

---

## `(?:●)` でグループを作るがキャプチャしない

このような場合には「キャプチャしないグループ化」である `(?:●)` を利用します。

これにより、格納する変数をシンプルにし、どこをキャプチャしたいのかをプログラム上で明確にすることができます。

```perl
if ('perl girl' =~ /(?:p..l) (g..l)/){
    # 最初のグループ化をキャプチャしない、という意図をコード上で明確にする
    print $1 . "\n";    # girl
}else{
    print "no match" . "\n";
}
```

---

## メタ文字 `●*?` 怠惰なマッチ

`*` に合致する正規表現 ● があった場合、できるだけ長い文字列を取得します。これを Greedy mach 強欲なマッチとも呼びます。

先にあげた例がまさに強欲なマッチの例です。

```perl
if ('perl girl' =~ /(p.*rl)/){
    print $1 . "\n";    # perl girl
}else{
    print "no match" . "\n";
}
```

これに対し、合致するできるだけ短い文字列を取得する動作が lazy match 怠惰なマッチです。

```perl
if ('perl perfect girl' =~ /(p.*?rl)/){
    print $1 . "\n";    # perl
}else{
    print "no match" . "\n";
}
```

---

## メタ文字 `●|◎` 左右の正規表現 `●◎` のどちらかにマッチする

<ruby>`|`<rt>バー</rt></ruby> で区切られた、左右にある正規表現のどちらかにマッチするか判定します。


```perl
if ('perl' =~ /r.by|p.rl/){
    print "match" . "\n";   # こちらが表示される
}else{
    print "no match" . "\n";
}
```

---

## メタ文字 `●|◎` 左右の正規表現 `●◎` のどちらかにマッチする

`()` と組み合わせて、マッチした文字列をキャプチャする方法がよくとられます。

```perl
if ('perl' =~ /(r.by|p.rl)/){
    print $1 . "\n";    # perl
}else{
    print "no match" . "\n";
}
```

---

## 練習問題（考え中）

以下についての問題

```
| (●) | グループを作る。正規表現 ● にマッチした場合、キャプチャを行う
| (?:●) | グループを作るが、キャプチャは行わない
| ●*? | ●* と同じ意味だが、マッチパターンが複数ある場合、 ●* はなるべく長くマッチするのに対し、 ●*? はなるべく短くマッチする
| ●\|◎ | 左右の正規表現 ●◎ のどちらかにマッチする
```

---

## 文字を表す文字、メタ文字（3/3）

| メタ文字 | 説明 |
| - | - |
| ^● | 正規表現 ● の冒頭にある場合、文字列の冒頭でのみマッチする
| ●$ | 正規表現 ● の末尾にある場合、文字列の末尾でのみマッチする
| \s | 空白、改行、タブのうち 1 文字を表す
| \d | 数字 1 文字を表す
| \b | 単語境界| \d | 数字 1 文字を表す

---

## メタ文字 `^` 正規表現が冒頭にある場合のみマッチする

正規表現の位置によって、マッチするかどうかを判定することも可能です。まずは冒頭からです。

```perl
if ('perl' =~ /^p/){    # 冒頭に p があるか？
    print "match" . "\n";   # こちらが表示される
}else{
    print "no match" . "\n";
}
```

```perl
if ('ruby' =~ /^p/){
    print "match" . "\n";
}else{
    print "no match" . "\n";   # こちらが表示される
}
```

---

## メタ文字 `^` 正規表現が冒頭にある場合のみマッチする

この `^` は、文字クラス `[ ]` の中にあると否定の意味になることは先に紹介しました。

複雑な条件を限られた記号で表す必要があるため、同じ記号でも使われる場所によって意味が異なってきます。

最初は混乱すると思うのですが、使っていると慣れて判別がつくようになります。

---

## メタ文字 `$` 正規表現が末尾にある場合のみマッチする

位置による正規表現マッチ、次は末尾です。

```perl
if ('perl' =~ /l$/){
    print "match" . "\n";   # こちらが表示される
}else{
    print "no match" . "\n";
}
```

```perl
if ('ruby' =~ /l$/){
    print "match" . "\n";
}else{
    print "no match" . "\n";   # こちらが表示される
}
```

---

## メタ文字 `\s` 空白、改行、タブのうち 1 文字を表す

文字の種別によるマッチです。`\s` は空白を表すメタ文字です。

```perl
if ('perl girl' =~ /(?:.+rl)\s(?:.+rl)/){   # 空白 1 つ
    print "match" . "\n";   # こちらが表示される
}else{
    print "no match" . "\n";
}
```

```perl
if ('perl          girl' =~ /(?:.+rl)\s+(?:.+rl)/){ # 複数の空白
    print "match" . "\n";   # こちらが表示される
}else{
    print "no match" . "\n";
}
```

---

## メタ文字 `\d` 数字 1 文字を表す

```perl
if ('perl 5' =~ /perl \d/){
    print "match" . "\n";   # こちらが表示される
}else{
    print "no match" . "\n";
}
```

```perl
if ('2021' =~ /\d\d\d\d/){
    print "match" . "\n";   # こちらが表示される
}else{
    print "no match" . "\n";
}
```

---

## メタ文字 `\b` 単語境界を表す

単語境界とは「文字列の先頭」「文字列と文字列の間」「文字列の最後」のことを言います。

```perl
if ('hello perl' =~ /\bperl\b/){
    print "match" . "\n";   # こちらが表示される
}else{
    print "no match" . "\n";
}
```

```perl
if ('hello perlmonger' =~ /\bperl\b/){
    print "match" . "\n";
}else{
    print "no match" . "\n";   # こちらが表示される
}
```


---

## 量指定子 `●{n}` n回の正規表現の繰り返し

`?`, `*`, `+` といった 0 回, 1 回, 1 回以上といった指定の他に、柔軟に正規表現の繰り返しを指定する方法があります。

それが量指定子です。　

例えば、2021-09-25 のような文字列は以下のようにマッチさせることができますが、記述が冗長です。

```perl
if ( '2021-09-25' =~ /\d\d\d\d-\d\d-\d\d/ ) {
    print "ok";
}
```

---

## 量指定子 `●{n}` n回の正規表現の繰り返し

あらかじめ繰り返しの数がわかっている場合には、量指定子 `{n}` を利用すると見やすく記述することができます。

```perl
if ( '2021-09-25' =~ /\d{4}-\d{2}-\d{2}/ ) {
    print "ok";
}
```

量指定子は以下のような繰り返し回数の指定も可能です。

-  `●{n,}`

    n回以上の正規表現の繰り返し

- `●{n,m}`

    n回以上、m回以下の正規表現の繰り返し

---

## 練習問題（考え中）

```
| ^● | 正規表現 ● の冒頭にある場合、文字列の冒頭でのみマッチする
| ●$ | 正規表現 ● の末尾にある場合、文字列の末尾でのみマッチする
| \s | 空白、改行、タブのうち 1 文字を表す
| \d | 数字 1 文字を表す
| \b | 単語境界| \d | 数字 1 文字を表す
```

- 量指定子をつかって、`2021-10-06` にも `2021-1-6` にもマッチする正規表現を作りましょう。

---

## 正規表現を用いた置換

これまでは、正規表現を用いて特定の文字のテスト、マッチ、キャプチャを行ってきました。

さらにマッチした文字列の置換を行うことができます。

```perl
my $greet = "Hello! Alice";
$greet =~ s/Alice/Perl/;

print $greet . "\n";    # Hello! Perl
```

単語境界を用いてこのように書くこともできます。
```perl
my $greet = "Hello! Alice";
$greet =~ s/\bA.+\b/Perl/;

print $greet . "\n";    # Hello! Perl
```

---

## 区切り記法の変更

ファイルの位置を示す <ruby>path<rt>パス</rt></ruby> や url を正規表現で置換する際に、正規表現で用いる区切り文字 `/` と URL の区切り文字である `/` が混在して見難くなる場合があります。

このような場合には、正規表現を囲む区切り文字 `/ /` を変えることができます。

```perl
my $path = '/usr/local/bin/perl';
$path =~ s{/usr/local/bin/}{/usr/bin/}; # { } に変えている

print $path . "\n"; # /usr/bin/perl
```

---

## 区切り記法の変更

置換だけではなく、マッチを探す際にも区切り文字を変更することが可能です。

その場合には `m{●}` と書きます。実はこれまでに学習した `/ /` は `m/ /` の省略形でした。

```perl
if ('perl' =~ m{p..l} ){
    print "match" . "\n";   # こちらが表示される
}else{
    print "no match" . "\n";
}
```

---

## 修飾子

例えば、大文字小文字を問わずに検索したい場合、これまで学習した内容だと文字クラスを使って表すことができます。

```perl
if ('Perl' =~ /[pP][eE][rR][lL]/){
    print "match" . "\n";   # こちらが表示される
}else{
    print "no match" . "\n";
}
```

しかし、もっと簡単に書く方法があります。それが **i 修飾子** です。i 修飾子を使うことで、マッチの際に大文字小文字を区別しなくなります。

```perl
if ('Perl' =~ /perl/i ){    # i修飾子
    print "match" . "\n";   # こちらが表示される
}else{
    print "no match" . "\n";
}
```

---

## エスケープ

正規表現では任意の一文字を表す <ruby>`.`<rt>ドット</rt></ruby> ですが、この <ruby>`.`<rt>ドット</rt></ruby> そのものをマッチや置換対象にしたいときはどうすれば良いでしょう？

ドットの他にも <ruby>`/`<rt>スラッシュ</rt></ruby> や <ruby>`\`<rt>バックスラッシュ</rt></ruby> 、<ruby>`+`<rt>プラス</rt></ruby>、<ruby>`*`<rt>アスタリスク</rt></ruby> 、<ruby>`[ ]`<rt>角かっこ</rt></ruby> など、正規表現中で特別な意味を持つ記号を検索したいときはどうすれば良いでしょう？

---

## エスケープ

そのようなときは <ruby>`\`<rt>バックスラッシュ</rt></ruby> をその記号の前においてください。

```perl
if ('.net' =~ /\.net/ ){     # .
    print "match" . "\n";   # こちらが表示される
}else{
    print "no match" . "\n";
```

バックスラッシュ自体をマッチさせたい時には `\\` のように、バックスラッシュを2回続けて記述します。

```perl
if ('\\\\' =~ /\\+/ ){      # 複数のバックスラッシュ
    print "match" . "\n";   # こちらが表示される
}else{
    print "no match" . "\n";
}
```

このように、その記号がもつ特別な働きを無効にすることを「エスケープする」といいます。

---

## 練習問題

（考え中）

```
- 特定の文字を「含まない」

- 2021-09-25 といった、4桁の数字, ハイフン, 2桁の数字, ハイフン, 2桁の数字を連結したもの

- 行頭に「メロス」が存在する行のみ

```

---

## ここまでが正規表現入門

駆け足で正規表現について学習してきました。

正規表現はプログラムの中だけではなく、テキストエディタや Everything（Windows）などの検索ツールでも利用が可能です。

特定の文字列を抜き出したい、曖昧な条件の単語を置き換えたい、という場面は意外に多いものです。

少なくとも、正規表現というものがあり、それを使えばうまいこと文字列処理をやれる。正規表現といえば Perl ！ ということを知っているだけでも大きいです。

---

## 更なる正規表現の学習へ

例えば、「東京都」と「京都」という文字列が与えられた時に、京都にのみマッチさせるにはどのような正規表現を使えば良いでしょう？

```perl
use utf8;
my @cities = ( '京都', '東京都' );
for my $city (@cities) {
    if ( $city =~ /京都/ ) {
       print $city . "\n";  # 京都 も 東京都 も表示されてしまう
    }
}
```

---

## 更なる正規表現の学習へ

このような場合には「否定の<ruby>後読<rt>あとよ</rt></ruby>み」を使うことで 京都 のみマッチさせることが可能です。

```perl
use utf8;
my @cities = ( '京都', '東京都' );
for my $city (@cities) {
    if ( $city =~ /(?<!東)京都/ ) {    # 京都 のみ表示される。否定の後読み
        print $city . "\n";
    }
}
```

---

## 更なる正規表現の学習へ

今回の講義資料については、以下の Web+DB Press vol.113 の Perl Hackers Hub の記事を参考にしています。

先に紹介した「否定の後読み」などについても解説があります。ぜひ見てください。

第58回　正規表現の勘所―わかりづらい記法の覚え方，先読みや後読みの実践（1）：Perl Hackers Hub｜gihyo.jp … 技術評論社
https://gihyo.jp/dev/serial/01/perl-hackers-hub/005801
