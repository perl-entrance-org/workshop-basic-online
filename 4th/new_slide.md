# Perl 入学式 第 4 回

## サブルーチン / リファレンス /<br> 正規表現 編



---

## 諸注意

### 会場について

- 飲食の可否

- 手洗いの場所

- 喫煙場所

---

## 諸注意

### 講義の進行について

- 講義中の疑問点

- うまくプログラムが動かない

- 分からない

上記についてはサポーターが適宜回答やアドバイスを Discord でおこないます。

テキストまたは音声チャットにて個別にサポートしますので、気軽に質問してください。

- <a href="https://discord.gg/2QNqVyk" target="_blank">Discord | 会話や交流が楽しめるプラットフォーム</a>

---

## 諸注意

### 講義環境について

- Youtube

- スライド共有ツール

- Discord

---

## 諸注意

### 本日のサポーター紹介



---

# サブルーチン

---

## サブルーチン

### サブルーチンとは?

プログラムの中で、意味や内容がまとまっている作業をひとかたまりにしたものを **サブルーチン** と呼びます。

Perl におけるサブルーチンは、「関数」とほぼ同義です。

---

## サブルーチン

### サブルーチンと組み込み関数

Perl には、これまで使ってきた `print` や `join` など、Perl が提供する関数（組み込み関数）が用意されています。

サブルーチンを使うことで、 `print` や `join` のように、「特定の処理を行うプログラム」をひとかたまりにして、 簡単に利用することが出来るようになります。

---

## サブルーチン

### サブルーチンの利点

サブルーチンを使い、特定の処理を分離することでプログラムの見通しをよくすることができ、コードの再利用も容易になります。

また、Perl の学習を進める上で「オブジェクト指向」は避けて通れません。このオブジェクトを構成する要素の一つがサブルーチンです。（他にはリファレンスがありますが、それは次回でやります）

---

## サブルーチン

### サブルーチンの定義

それでは、早速サブルーチンを定義していきましょう。

今回は、末尾に自動的に改行 `\n` を付与しながら文字列を表示する `say` というサブルーチンを定義してみます。

---

## サブルーチン

### サブルーチンの定義

```perl
sub say {               # -┐
    my $str = shift @_; #  │ サブルーチン say を
    print "$str\n";     #  │ 定義しているところ
}                       # -┘ サブルーチン末尾に ;　は不要
say("hello, world!"); # hello, world!
```

Perl でサブルーチンを定義する為には、以下のように書きます。

サブルーチンの末尾 `}` の後に `;` は不要です。

```perl
sub サブルーチン名 { ... }
```

それでは、詳しく見て行きましょう。

---

## サブルーチン

### サブルーチンの命名規則

```perl
sub say { ... }
```

- サブルーチン名として使える文字は以下です。

  - 大文字・小文字の英数字
  - アンダースコア(`_`)

- ただし、サブルーチン名の先頭文字には以下の制限があります。
  - 英文字
  - `_`

これは変数名と同じルールです。

---

## サブルーチン

### Perl におけるサブルーチンの命名規則

```perl
sub say_hello_world { ... }

sub say_good_morning { ... }
```

変数名と同様に、サブルーチン名は <ruby>`_`<rt>アンダースコア</rt></ruby> で単語をつなげたスネークケース（snake_case）を利用します。

サブルーチンは機能をまとめたものになるため、その名称が単語で終わることは少ないです。

わかりやすい名前づけを意識しましょう。

---

## サブルーチン

### サブルーチンの呼び出し

```perl
say();
```

定義したサブルーチンは、定義したサブルーチン名の後ろに `()` を付けることで利用できます。

行末に書く場合には、 `;` が必要です。

このようにサブルーチンを利用することを「**サブルーチンの呼び出し**」といいます。

---

## サブルーチン

### サブルーチンの呼び出し

```perl
say('Hello Perl!');
```

サブルーチンに値(引数)を渡したい場合、 `()` の中に書きます。

`()` を使わずに, サブルーチン名の先頭に `&` を付けて `&say` という書き方で呼びだすこともできますが、古い書き方なので使わないようにしましょう。

---

## サブルーチン

### サブルーチンの引数

```perl
sub say {
    my $str = shift @_; # ←┐
    print "$str\n";     #  │ サブルーチンの引数 'Hello Perl' は
}                       #  │ @_ という配列に格納される
                        #  │
say('Hello Perl');      # ─┘
```

サブルーチンに与えられた引数は、 `@_` という配列に格納されます。

2 行目では、`shift` を使って、この　`@_` の先頭の要素を取得しています。

このサブルーチンを `say('hoge');` のように呼んだ場合、 `@_` の中身は`('hoge')` となり、 `$str` には `hoge` という文字列が入ります。

---

## サブルーチン

### サブルーチンの引数

```perl
sub say {
    my $str = shift;  # @_ が省略されている
    print "$str\n";
}

say('Hello Perl');    # Hello Perl
```

`@_` は、省略することができます。

`my $str = shift;`

は、

 `my $str = shift @_;`

 と同じ意味になります。

---

## サブルーチン

### サブルーチンの位置

```perl
say('Hello Perl');  # Hello Perl

sub say {
    my $str = shift;
    print "$str\n";
}
```

同じファイル内であれば、サブルーチンの位置にかかわらず `say('hoge');` として呼び出すことができます。

ファイル末尾にサブルーチンがまとまっている方が見やすい場合は、このスタイルで書きましょう。

---

## サブルーチン

### サブルーチンに複数の引数を渡す

```perl
sub plus {
    my ($first, $second) = @_;  # @_ の中に 2, 5が入る
    return $first + $second;    # ↑
}                               # │
                                # │
my $result = plus(2, 5);        # ┘ plus の引数 2, 5
print $result . "\n";   # 7
```
サブルーチンに複数の引数を与える時は、呼び出し時に`( )` の中で配列のようにカンマ　`,` で区切って渡します。

サブルーチン側では `@_` を右辺に起き、個別に変数に代入して受け取ります。


---

## サブルーチン

### サブルーチン側の引数の受け取り方

```perl
sub plus {
                        # @_ を省略した場合
    my $first  = shift;  # @_ の先頭から1つ取り出して変数に入れている
    my $second = shift;  # @_ の先頭から1つ取り出して変数に入れている
    return $first + $second;
}
my $result = plus(2, 5);
```

```perl
sub plus {
    my $first  = $_[0];  # $_[0] : @_ の最初の要素
    my $second = $_[1];  # $_[1] : @_ の次の要素
    return $first + $second;
}
my $result = plus(2, 5);
```

先程の引数の受け取り方は、上記のプログラムと同じ意味になります。

---

## サブルーチン

### 返り値と return

```perl
sub plus {
    my ($first, $second) = @_;
    return $first + $second;  # $first + $second の結果を返す
}
my $result = plus(2, 5);
print $result . "\n";   # 7
```

サブルーチンは, `return` を使うことで、任意のデータを呼び出し元へ返すことができます。

サブルーチンや関数の処理結果のことを **<ruby>返り値<rt>かえりち</rt></ruby>** といいます。

この場合、 `$first + $second` の計算結果が呼び出し元へ返され、 `$result` に格納されます。

---

## サブルーチン

### 複数の return

```perl
sub is_same {
    my ( $first, $second ) = @_;
    if ( $first eq $second ) {
        print "true\n";    # $first と $second が等しければ表示
        return 1;
    }
    else {
        print "false\n";    # $first と $second が異なれば表示
        return 0;
    }
    print "YOU WILL NEVER SEE IT\n"; # 絶対に表示されない!
    return;
}
```

`return` に到達した場合、それ以降の処理は一切行われず、すぐさま値を返してサブルーチンの実行を終了します。（ガード節といいます）

---

## サブルーチン

### 複数の返り値

```perl
sub plus_and_minus {
    my ( $first, $second ) = @_;

    # 複数の値を return で返す
    return ( $first + $second, $first - $second );
}
my @results = plus_and_minus( 5, 4 );
print $results[0] . "\n";    # 足し算の結果
print $results[1] . "\n";    # 引き算の結果
```

サブルーチンは、このようにリストを返すことで複数個の値を返すこともできます。

---

## サブルーチン

### return がない場合の返り値

```perl
sub plus {
    my ($first, $second) = @_;
    $first + $second;         # サブルーチンの中で最後に評価された行
}

my $result = plus(2, 5);
print $result . "\n";   # 7
```

サブルーチンの中に `return` がない場合、サブルーチンの返り値は最後に評価された処理の結果（この場合、 `$first + $second`の計算結果）を返します。

値を返すという意図を明確にするため、 `return` は書くようにしましょう。

---

## サブルーチン

### 副作用を避ける

サブルーチンの返り値に改行を加えて返すこともできます。`plus` 関数と `say` 関数を合わせたようなものです。

```perl
sub plus {
    my ($first, $second) = @_;
    my $sum = $first + $second;
    return $sum . "\n";
}

my $result = plus(2, 5);
print $result;   # 7 を表示して改行
```

一見、改行を加える手間が省けてよく見えるかもしれません。

しかし、このような実装は避けましょう。

---

## サブルーチン

### 副作用を避ける

サブルーチンは「FizzBuzzの結果を返す」「引数に改行を加えて返す」などの単機能で実装しましょう。

複数の機能が合わさった関数は、問題発生時の切り分けが難しくなります。

そして、今回のように `plus` というサブルーチン名から、返り値に改行が加わることは予見できません。

書いた時は良くても、3日後の自分、まして他人が予見することはできません。

このように、意図しない動作が加わることを **副作用** と呼びます。

関数は副作用がないよう、単機能で作り、組み合わせて利用しましょう。

---

## サブルーチン

### 副作用を避ける

単機能のサブルーチンを組み合わせた例です。

```perl
# 足し算した結果を返すだけの関数
sub plus {
    my ( $first, $second ) = @_;
    return $first + $second;
}

# 改行を加えて print するだけの関数
sub say {
    my $arg = shift;
    print $arg . "\n";
}

my $result = plus( 2, 5 );
say($result);    # 7 を表示して改行

# 関数の中に関数を入れることもできる
say( plus( 2, 5 ) );    # 7 を表示して改行
```

---

## 練習問題 `fizzbuzz_sub.pl`

配列の項で学習した FizzBuzz をサブルーチンで実装した FizzBuzz サブルーチンを作り、呼び出した結果を表示してください。

- その数字が `3` で割り切れるなら `Fizz` を返す。
- その数字が `5` で割り切れるなら `Buzz` を返す。
- その数字が `3` でも `5` でも割り切れるなら `FizzBuzz` を返す。
- その数字が `3` でも `5` でも割り切れないなら その数字 を返す。

余裕がある人は、for 文と組み合わせて 1 から 100 までを fizzbuzz してみましょう。

---

## 練習問題 `fizzbuzz_sub.pl`

コード例です。

```perl
print fizzbuzz(1) . "\n";   # 1
print fizzbuzz(2) . "\n";   # 2
print fizzbuzz(3) . "\n";   # Fizz
print fizzbuzz(4) . "\n";   # 4
print fizzbuzz(5) . "\n";   # Buzz
# 中略
print fizzbuzz(15) . "\n";  # FizzBuzz
```

---

## 出来た方は、Discord のテキストチャットで「出来た！」とリアクションお願いします！

---

## 休憩 ＆ 質問 ＆ 雑談 タイム<br>（5 〜 10 分）


---

# コラム：<br>検索 vs 書籍

---

## コラム：検索 vs 書籍

ネットで検索できるなら書籍は不要でしょうか？

たしかに検索する（ググる）ことで問題が解決することも多いです。

しかし、書籍を通読することで体系だった知識を身につけることができます。

ネットの情報は玉石混交、一方で書籍の場合は情報の陳腐化があり、一長一短と言えます。

ここでは Perl入学式おすすめの書籍を紹介します。

---

## コラム：検索 vs 書籍

- 「[プログラミング Perl](https://www.oreilly.co.jp/books/4873110963/)」(通称: ラクダ本)

    Perl の書籍の決定版ではあるが、プログラミング未経験の初心者にはハードルが高いオライリー本。1000p 超の 2 分冊。海外では第 4 版まで出版されていますが、日本では第 3 版まで。

- 「[初めての Perl](https://www.oreilly.co.jp/books/9784873118246/)」(通称: リャマ本)

    若干プログラミング初心者向け。他のプログラミング言語を習得していれば、すぐ読み始めても大丈夫。

- 「[CPAN モジュールガイド](https://www.borndigital.co.jp/book/7427.html)」

    Perl に機能追加できる CPAN モジュールを紹介した本。Perl の可能性を知ることができる良書。

---

## コラム：検索 vs 書籍


- 「[雅な Perl](https://booth.pm/ja/items/260345)」

    一般流通に乗らない同人誌であるが、通販で購入できるようになった。Perl入学式で学ぶ範囲と重なるところも多く、初心者向けにわかりやすい解説をしている。

- 「[もっと自在にサーバを使い倒す 業務に役立つ Perl](https://gihyo.jp/book/2012/978-4-7741-5025-3)」

    サーバーのログ加工を中心に、Perl の実用例を学べる。

- 「[すぐわかるオブジェクト指向 Perl](https://gihyo.jp/book/2008/978-4-7741-3504-5)」

    Perl入学式で基礎を押さえたら挑戦したい「オブジェクト指向 Perl」を解説。
    初心者にとっての難関であるリファレンスについても、親切丁寧に解説しています。


---

## コラム：検索 vs 書籍

- 「[そろそろ常識?マンガでわかる正規表現](https://libroworks.co.jp/?p=3271)」

    Perl の大きな特徴である正規表現についてマンガ形式で解説しておりわかりやすい。Perl入学式の範囲 + アルファ を解説しているので、復習とステップアップにちょうど良い。

- 「[入門者のLinux 素朴な疑問を解消しながら学ぶ (ブルーバックス)](https://bookclub.kodansha.co.jp/product?item=0000194950)」

    第 1 回で学ぶシェルでの操作を解説した本。`cd`, `ls` の説明から始まり、リダイレクトで `awk` などに渡すなどシェルの基本を学ぶことができます。




---

# リファレンス

---
## リファレンス、その前に

### これまで学んだ変数

Perlの変数として以下の 3 種類について学んできました。

- スカラー変数 `$scalar`

- 配列 `@array`

- ハッシュ `%hash`

---

## リファレンス、その前に

### 複雑なデータ構造

しかし、これらだけでは複雑なデータ構造を構築・利用することができません。

例えば以下のようなデータです。　

|  Name   | Japanese | Math |
| ------- | -------- | ---- |
|  Alice  |    60    |  90  |
|  Bob    |    70    |  70  |
|  Charie |    80    |  80  |


---

## リファレンス、その前に

### 複雑なデータ構造

|  name   | Japanese | math |
| ------- | -------- | ---- |
|  Alice  |    60    |  90  |
|  Bob    |    70    |  70  |
|  Charie |    80    |  80  |


スカラー変数で頑張る場合（生徒数×3の変数宣言が必要）

```perl
my $alice_name     = 'Alice';
my $alice_japanese = 60;
my $alice_math     = 90;
```

---

## リファレンス、その前に

### 複雑なデータ構造

|  name   | Japanese | math |
| ------- | -------- | ---- |
|  Alice  |    60    |  90  |
|  Bob    |    70    |  70  |
|  Charie |    80    |  80  |


配列で頑張る場合（生徒の数だけ配列の宣言が必要）

```perl
my @alice = ( 'Alice', 60, 90 );
my @bob   = ( 'Bob',   70, 70 );
my @carol = ( 'Carol', 80, 80 );
```

---

## リファレンス、その前に

### 複雑なデータ構造

|  name   | Japanese | math |
| ------- | -------- | ---- |
|  Alice  |    60    |  90  |
|  Bob    |    70    |  70  |
|  Charie |    80    |  80  |


ハッシュで頑張る場合（配列と同じく生徒の数だけハッシュの宣言が必要）

いずれの場合も、生徒全員の合計点や平均点を出そうと思った時に苦労します。

```perl
my %alice  = ( name => 'Alice',  japanese => 60, math => 90 );
my %bob    = ( name => 'Bob',    japanese => 70, math => 70 );
my %charie = ( name => 'Charie', japanese => 80, math => 80 );
```

---

## リファレンス、その前に

### 複雑なデータ構造

|  name   | Japanese | math |
| ------- | -------- | ---- |
|  Alice  |    60    |  90  |
|  Bob    |    70    |  70  |
|  Charie |    80    |  80  |

この複雑なデータ構造は、「配列の中にハッシュが入っている」と見ることができます。

```
(
    ( name => 'Alice',  japanese => 60, math => 90 ),
    ( name => 'Bob',    japanese => 70, math => 70 ),
    ( name => 'Charie', japanese => 80, math => 80 ),
)
```

---

## リファレンスとは

### 複雑なデータ構造

では、このデータ構造をこれまで学んだ範囲で表現してみます。

```perl
(
    ( name => 'Alice',  japanese => 60, math => 90 ),
    ( name => 'Bob',    japanese => 70, math => 70 ),
    ( name => 'Charie', japanese => 80, math => 80 ),
)
```

しかし、この方法ではうまくいきません。

```perl
my @array = (
    ( name => 'Alice', japanese => 60, math => 90 ),
    ( name => 'Bob',    japanese => 70, math => 70 ),
    ( name => 'Charie', japanese => 80, math => 80 ),
);

print "@array"; # name Alice japanese 60 math 90 name Bob japanese 70 math 70 name Charie japanese 80 math 80
```

---

## リファレンスとは

### 複雑なデータ構造

先の例のように、配列の中でハッシュはそのデータ構造を維持することができません。

配列の配列、ハッシュの中の配列、ハッシュの中のハッシュも同様です。

配列の要素は **スカラー変数** のみ格納できます。

ハッシュの値（value）も **スカラー変数** のみ格納できます。

---

## リファレンスとは

### 複雑なデータ構造


ここで **リファレンス** を利用します。

リファレンスを利用することで、配列やハッシュをスカラー変数として扱うことができます。

他のプログラム言語を学んだ人は「間接参照」と言えば聞いたことがあるかもしれません。

リファレンスの作り方には 2 つの方法があります。

---

## リファレンスの作り方

### 1. 配列・ハッシュを作り、それをリファレンス化してスカラー変数にする方法

配列・ハッシュをリファレンス化するためには、元の変数に <ruby>`\`<rt>バックスラッシュ</rt></ruby> をつけてスカラーに代入します。

```perl
my @alice_score     = ( 60, 90 );
my $alice_score_ref = \@alice_socre;    # バックスラッシュをつけて代入
```

```perl
my %alice     = ( name => 'Alice', japanese => 60, math => 90 );
my $alice_ref = \%alice;    # バックスラッシュをつけて代入
```

---

## リファレンスの作り方

### 2. 無名配列・無名ハッシュ（データを直接リファレンスとして格納する方法）

無名配列の「無名」は配列・ハッシュとしての名を持たない（宣言していない）と考えてください。

- 配列の場合（右辺のリストが <ruby>`[ ]`<rt>角かっこ</rt></ruby> で囲われていることに注意！）

```perl
my $alice_score_ref = [ 60, 90 ];
```

- ハッシュの場合（右辺のリストが <ruby>`{ }`<rt>波かっこ</rt></ruby> で囲われていることに注意！）

```perl
my $alice_ref = { name => 'Alice', japanese => 60, math => 90 };
```

---

## リファレンスの中身の確認方法

### print だけでは確認できない

リファレンスは配列やハッシュをスカラーにしたものですが、そのまま `print` しても中身を表示することができません。

```perl
my @alice           = ( 60, 90 );
my $alice_score_ref = \@alice;      # バックスラッシュをつけて代入

# 直接ハッシュリファレンスを作成
my $alice_ref = { name => 'Alice', japanese => 60, math => 90 };

print $alice_score_ref . "\n";      #ARRAY(0x7fc9fa012898)

print $alice_ref . "\n";            #HASH(0x7fc9fa00e3b8)
```

リファレンスの中身を確認したいときは、ハッシュの中身を確認するときに利用した `Data::Dumper` モジュールを利用します。

---

## リファレンスの中身の確認方法

### Data::Dumper で配列リファレンスを確認する

```perl
use Data::Dumper;

my @alice           = ( 60, 90 );
my $alice_score_ref = \@alice;      # バックスラッシュをつけて代入

print Dumper $alice_score_ref;
```

```perl
$VAR1 = [
          60,
          90
        ];
```

---

## リファレンスの中身の確認方法

### Data::Dumper でハッシュリファレンスを確認する

```perl
use Data::Dumper;

# 無名ハッシュを作成
my $alice_ref = { name => 'Alice', japanese => 60, math => 90 };

print Dumper $alice_ref;
```

```perl
$VAR1 = {
          'name' => 'Alice',
          'japanese' => 60,
          'math' => 90
        };
```

---

## リファレンスで複雑なデータ構造を作成する

ここまで学習したことを利用すると、以下のデータ構造を Perl で構築することが可能になります。

|  name   | Japanese | math |
| ------- | -------- | ---- |
|  Alice  |    60    |  90  |
|  Bob    |    70    |  70  |
|  Charie |    80    |  80  |


---

## リファレンスで複雑なデータ構造を作成する

以下は「配列・ハッシュを作り、それをリファレンス化したスカラー変数を作る方法」です。3 人のデータをハッシュリファレンスにして、配列に格納しています。

```perl
use Data::Dumper;

my %alice     = ( name => 'Alice', japanese => 60, math => 90 );
my $alice_ref = \%alice;

my %bob     = ( name => 'Bob', japanese => 60, math => 90 );
my $bob_ref = \%bob;

my %charie     = ( name => 'Charie', japanese => 60, math => 90 );
my $charie_ref = \%charie;

my @array = ( $alice_ref, $bob_ref, $charie_ref );
print Dumper \@array;
```

---

## リファレンスで複雑なデータ構造を作成する

先のプログラムの実行結果です。3 人の名前や成績データを 1 つの配列の中に格納することができました。

```perl
$VAR1 = [
          {
            'japanese' => 60,
            'name' => 'Alice',
            'math' => 90
          },
          {
            'name' => 'Bob',
            'japanese' => 60,
            'math' => 90
          },
          {
            'math' => 90,
            'name' => 'Charie',
            'japanese' => 60
          }
        ];
```

---

## 練習問題（make_reference.pl）

1. 以下のデータをリファレンス化してください。各行を無名ハッシュで作成し、そのハッシュリファレンスを格納した配列を作ります。

    直接配列内に記述しても、ハッシュリファレンスを配列に格納する方法でも、どちらでも構いません。

|  name   | Japanese | math |
| ------- | -------- | ---- |
|  Alice  |    60    |  90  |
|  Bob    |    70    |  70  |
|  Charie |    80    |  80  |

2. リファレンス化したデータを `Data::Dumper` モジュールを利用して中身を表示してください。

---

## リファレンスの利用法

### デリファレンス

配列・ハッシュをリファレンス化することで、「配列の中のハッシュ」「ハッシュのハッシュ」などの複雑なデータ構造を作成し、スカラー変数に格納することができるようになりました。

今度はそのスカラー変数からデータを取り出す方法を学んでいきます。

まずはリファレンス化してスカラー変数にしたデータを、元の配列・ハッシュに戻す **デリファレンス** です。

---

## リファレンスの利用法

### 配列リファレンスをデリファレンスする

元の配列に戻すときは、配列リファレンスを `@{ }` で囲みます。

```perl
my @alice_score     = ( 60, 90 );
my $alice_score_ref = \@alice_score;

# デリファレンスして配列に戻す
my @alice_score_deref = @{$alice_score_ref};    # リファレンスを @{ } で囲んでいる
print $alice_score_deref[0] . "\n";             # 60
```

---

## リファレンスの利用法

### ハッシュリファレンスをデリファレンスする

元のハッシュに戻すときは、ハッシュリファレンスを `%{ }` で囲みます。

```perl
my %alice     = ( name => 'Alice', japanese => 60, math => 90 );
my $alice_ref = \%alice;

# デリファレンスしてハッシュに戻す
my %alice_deref = %{$alice_ref};    # リファレンスを %{ } で囲んでいる
print $alice_deref{name} . "\n";    # Alice
```

このように、リファレンスを元の種類の変数に戻すときは、配列かハッシュかを意識して、それに応じたデリファレンスをすることが必要です。

---

## リファレンスの利用法

### 配列リファレンスをデリファレンスせずにデータを扱う

アロー記法を用いると、参照元に対応したシジルをつけることなく、簡易な記法でデータを取り出すことが可能です。


```perl
my @alice_score     = ( 60, 90 );
my $alice_score_ref = \@alice_score;

# アロー記法
print $alice_score_ref->[0] . "\n";    # 60

# 冗長だがこのようにも書ける
print ${$alice_score_ref}[0] . "\n";    # 60
```

---

## リファレンスの利用法

### ハッシュリファレンスをデリファレンスせずにデータを扱う

```perl
my %alice     = ( name => 'Alice', japanese => 60, math => 90 );
my $alice_ref = \%alice;

# アロー記法
print $alice_ref->{name} . "\n";    # Alice

# 冗長だがこのようにも書ける
print ${$alice_ref}{name} . "\n";    # Alice
```

アロー記法でも、配列の添字 `[0]` や ハッシュのキー名 `{name}` など、それぞれの変数に応じた記法を用います。デリファレンスと同様に、元データが配列であるかハッシュであるかを意識しておくことが大事です。

---

## リファレンスの利用法

### リファレンスのデータを更新する

リファレンスから直接データを取り出すこともできますが、リファレンスのデータを更新することも可能です。

ただし、リファレンスのデータを更新すると、リファレンス元の変数にも影響が及びます。注意しておきましょう。

```perl
my %alice     = ( name => 'Alice', japanese => 60, math => 90 );
print $alice{name} . "\n";  # Alice

my $alice_ref = \%alice;

$alice_ref->{name} = 'Dave';    # データを上書き

print $alice_ref->{name} . "\n";    # Dave

# リファレンス元の name も変わっている
print $alice{name} . "\n";    # Dave
```

---

## リファレンスの利用法

### 配列の関数をリファレンスに利用する（`for`）

デリファレンスしたものは元の配列・ハッシュと同じように扱うことができます。

```perl
use Data::Dumper;
my @alice_score     = ( 60, 90 );
my $alice_score_ref = \@alice_score;

for my $score ( @{$alice_score_ref} ) {
    print $score . "\n";    # 60 90
}
```

---

## リファレンスの利用法

### 配列の関数をリファレンスに利用する（`push`）

デリファレンスしたものは元の配列・ハッシュと同じように扱うことができます。

```perl
use Data::Dumper;
my @alice_score     = ( 60, 90 );
my $alice_score_ref = \@alice_score;

push @{$alice_score_ref}, 100;    # 配列と同じように扱っている
print Dumper $alice_score_ref;    # 元の配列の内容も変更されていることに注意
```

```perl
$VAR1 = [
          60,
          90,
          100
        ];
```

---

## リファレンスの利用法

### ハッシュの関数をリファレンスに利用する（`keys`）

デリファレンスしたものは元の配列・ハッシュと同じように扱うことができます。

```perl
use Data::Dumper;
my %alice     = ( name => 'Alice', japanese => 60, math => 90 );
my $alice_ref = \%alice;

my @keys = keys %{$alice_ref};    # ハッシュと同じように扱っている
print Dumper \@keys;              # 普通の配列にDumper使うときは \ を付ける
```

```perl
$VAR1 = [
          'japanese',   # 元はハッシュなので順不同
          'math',
          'name'
        ];
```

---

## 練習問題 `weather_report.pl`

以下は天気予報の応答をハッシュリファレンスにしたものです。

それぞれの項目の key と value を表示してください。

```perl
my $content = {
    publishingOffice => '気象庁',
    targetArea => '東京都',
    text  => '　日本海に中心を持つ高気圧が本州付近を覆っています。'
};
```

---

## 練習問題 `use_reference.pl`

以下の表を、配列 @members にハッシュリファレンスを格納して作成しました。各メンバーの名前、 japanese と math の値を合計したものを表示してください。（例：Alice => 150）

|  name   | Japanese | math |
| ------- | -------- | ---- |
|  Alice  |    60    |  90  |
|  Bob    |    70    |  70  |
|  Charie |    80    |  80  |


```perl
my @members = (
    { name => 'Alice',  japanese => 60, math => 90 },
    { name => 'Bob',    japanese => 70, math => 70 },
    { name => 'Charie', japanese => 80, math => 80 },
);
```

---

### リファレンスは難しい

ここまで学んできたリファレンスは難しい内容です。Perl の初心者向けの本には解説自体がないこともある内容です。

今回、このテキストでは利用法に絞った説明に特化しました。習うより慣れろ、という方針です。

わからないことや、このようなデータ構造はどう表すことができるか？といった疑問があれば、ぜひ Discord に書き込んでみてください。


---

## 出来た方は、Discord のテキストチャットで「出来た！」とリアクションお願いします！

---

## 休憩 ＆ 質問 ＆ 雑談 タイム<br>（5 〜 10 分）


---

# コラム：<br>Perl Hackers Hub

---

## コラム：Perl Hackers Hub

技術評論社が発行している「WEB+DB PRESS」という雑誌があります。

2022年4月に発売された Vol.128 に、Perl入学式の講師による「[初学者に伝えたい Perl学習の勘所](https://gihyo.jp/dev/serial/01/perl-hackers-hub/007201?summary)」が掲載されました。

講師達が Perl 入学式で受講生からよく寄せられる質問について解説しています。

雑誌掲載ではありますが、Web でも公開されています。是非参考にしてください。

---

## コラム：Perl Hackers Hub

この Perl Hackers Hub は 2011 年から続く連載です。

[Perl Hackers Hub 記事一覧](https://gihyo.jp/list/group/Perl-Hackers-Hub#rt:/dev/serial/01/perl-hackers-hub/007201)

これまでに多くの記事が掲載されてきました。

記事一覧から、自分の興味のある分野の記事を読んでみることをお勧めします。



---

# 正規表現

---

## データ処理に最適な「正規表現」

正規表現という語を聞いたことはありますでしょうか？正規表現を利用することで

- 文字列が「複雑な条件」に合致しているかテストする

- 「複雑な条件」に合致した文字列を検索する

- 「複雑な条件」に合致した文字列を置き換える・削除する

といったことが可能になります。

---

## 複雑な条件とは

ここでいう「複雑な条件」とは例えば以下のようなものです。

- p で始まり <ruby>l<rt>エル</rt></ruby> で終わる 4 文字

- 特定の文字を「含まない」

- 2021-09-25 といった、4桁の数字, ハイフン, 2桁の数字, ハイフン, 2桁の数字を連結したもの

- 行頭に「メロス」が存在する行のみ

---

## Perl と正規表現

Perl は他のプログラミング言語と比べて正規表現が書きやすい言語です。

また、ソフトウェアの正規表現の機能を Perl の正規表現の文法で提供しているソフトウェアもあります。これらで提供している正規表現は PCRE(Perl Compatible Regular Expressions) と呼ばれています。

Perl の正規表現でデータを取得、きれいに整形した後で他のプログラムで利用する、というように、組み合わせて利用されることも多い機能です。

---

## Perl と正規表現

正規表現は奥が深く、またそれだけで専門の分野がある広大な学問分野です。

Perl の正規表現は、それ自体が小さなプログラミング言語と思えるほどの機能を有しています。

Perl 入学式のみで全て紹介することはできませんが、コードを書く上でよく利用する「基本的な部分」を紹介していきます。

---

## 正規表現の用語について

まず、正規表現の用語を簡単に解説します。

- **メタ文字**

    文字そのものを表さない、特殊な意味を持つ正規表現内の文字。

- **マッチする**

    正規表現に合致する文字列を見つけること。

具体性が欠けるのでイメージしづらいと思うのですが、このあと実践して学習していきます。

まずはメタ文字です。

---

## 文字を表す文字、メタ文字（1/3）

| メタ文字 | 説明 |
| - | - |
| `.` | 任意の 1 文字にマッチする |
| `[■]` | 文字クラス。リスト `■` の中にある任意の 1 文字にマッチする
| `[^■]` | 否定の文字クラス。リスト `■` の中にない任意の 1 文字にマッチする
| `●?` | 正規表現 `●` が 0 個もしくは 1 個存在する
| `●*` | 正規表現 `●` が 0 個もしくは 1 個以上存在する
| `●+` | 正規表現 `●` が 1 個以上存在する

聞き慣れない用語の次に、今度は記号がたくさん出てきましたした。これから順に説明していきます。

---

## 正規表現でテストする

文字列の比較には比較演算子 `eq` を利用しました。

```perl
if ('perl' eq 'p..l'){
    print "match" . "\n";
}else{
    print "no match" . "\n";    # こちらが表示される
}
```

しかし、文字列の比較では「p ではじまり <ruby>l<rt>エル</rt></ruby> で終わる 4 文字の単語」という検索はできません。

---

## 正規表現でテストする

「p ではじまり <ruby>l<rt>エル</rt></ruby> で終わる 4 文字の単語」といった<ruby>曖昧<rt>あいまい</rt></ruby>な条件に合致するかをテストをするために、正規表現を利用します。

正規表現を利用してテストするときは、専用の演算子を利用します。

`=~` の左辺に比較したい文字列、右辺に正規表現を `//` で囲って記述します。

以下は `perl` という文字列が <ruby>`p..l`<rt>ピー ドット ドット エル</rt></ruby> という正規表現にマッチするかをテストするプログラムです。

```perl
if ('perl' =~ /p..l/){
    print "match" . "\n";   # こちらが表示される
}else{
    print "no match" . "\n";
}
```

---

## メタ文字 `.` （ドット）

正規表現中で使われている `.` （ドット）は「任意の1文字」を表します。

```perl
if ('perl' =~ /p..l/){
    print "match" . "\n";   # こちらが表示される
}else{
    print "no match" . "\n";
}
```

```perl
if ('pel' =~ /p..l/){
    print "match" . "\n";
}else{
    print "no match" . "\n";    # こちらが表示される
}
```

```perl
if ('perrl' =~ /p..l/){
    print "match" . "\n";
}else{
    print "no match" . "\n";    # こちらが表示される
}
```

---

## メタ文字 `[■]` 文字クラス

`[ ]`で囲まれた文字は **文字クラス** と言います。`■` は文字の集合を表したものです。

たとえば `[abcde]` は `a` 又は `b` 又は `c` 又は `d` 又は `e` いずれか 1 文字とマッチします。

```perl
if ('perl' =~ /p[abcde]rl/){
    print "match" . "\n";   # こちらが表示される
}else{
    print "no match" . "\n";
}
```

```perl
if ('perl' =~ /p[abcd]rl/){
    print "match" . "\n";
}else{
    print "no match" . "\n";    # こちらが表示される
}
```

---

## メタ文字 `[■]` 文字クラス

連続した文字であれば、`[a-e]`のように書くことも可能です。

ただし、ここでいう「連続した文字」とは **文字コード** というコンピュータ上での文字の並びになることに注意してください。

```perl
if ('perl' =~ /p[a-e]rl/){
    print "match" . "\n";   # こちらが表示される
}else{
    print "no match" . "\n";
}
```

---

## メタ文字 `[^■]` 否定の文字クラス

文字クラスの `[]` 内の先頭に <ruby>`^`<rt>キャレット</rt></ruby> を書くと、否定の文字クラスとなります。**文字クラスに書かれているもの以外の 1 文字** にマッチします。

```perl
if ('perl' =~ /p[^xyz]rl/){
    print "match" . "\n";    # こちらが表示される
}else{
    print "no match" . "\n";
}
```

```perl
if ('perl' =~ /p[^f-z]rl/){
    print "match" . "\n";   # こちらが表示される
}else{
    print "no match" . "\n";
}
```

```perl
if ('perl' =~ /p[^abcde]rl/){
    print "match" . "\n";
}else{
    print "no match" . "\n";    # こちらが表示される
}
```

---

## メタ文字 `●?` 直前の正規表現が 0 個もしくは 1 個存在する

いままでは `.` や `[a-e]` など 1 文字にマッチする正規表現を学んできました。ここからは複数の文字にマッチする正規表現を学んでいきます。

`●` は先に学習した任意の1文字を表す `.` や 文字クラス `[ ]` を表す正規表現としてみてください。

この `?` は **?の直前の正規表現 `●` が 0 個もしくは 1 個存在する時** にマッチします。

```perl
if ('perl' =~ /p.?rl/){
    print "match" . "\n";   # こちらが表示される
}else{
    print "no match" . "\n";
}
```

---

## メタ文字 `●?` 直前の正規表現が 0 個もしくは 1 個存在する

0 個というのは `?` の直前の正規表現 `●` が存在しない時もマッチするという意味になります。

```perl
if ('prl' =~ /p.?rl/){
    print "match" . "\n";   # こちらが表示される
}else{
    print "no match" . "\n";
}
```

---

## メタ文字 `●*` 直前の正規表現が 0 個もしくは 1 個以上存在する

先程の `?` は「その直前の正規表現 `●` が 0 個もしくは 1 個存在する時」でした。ここで紹介する `*` は **その直前の正規表現 `●` が 0 個または 1 個以上存在する時** にマッチします。

0 個のとき

```perl
if ('prl' =~ /p.*rl/){
    print "match" . "\n";   # こちらが表示される
}else{
    print "no match" . "\n";
}
```

---

## メタ文字 `●*` 直前の正規表現が 0 個もしくは 1 個以上存在する

1 個のとき

```perl
if ('perl' =~ /p.*rl/){
    print "match" . "\n";   # こちらが表示される
}else{
    print "no match" . "\n";
}
```

1 個以上の時
```perl
if ('perl girl' =~ /p.*rl/){
    print "match" . "\n";   # こちらが表示される
}else{
    print "no match" . "\n";
}
```

---

## メタ文字 `●+` 直前の正規表現が 1 個以上存在する

`+` は **その直前の正規表現 `●` が 1 個以上存在する時** にマッチします。

```perl
if ('perl' =~ /p.+rl/){
    print "match" . "\n";   # こちらが表示される
}else{
    print "no match" . "\n";
}
```

```perl
if ('prl' =~ /p.+rl/){
    print "match" . "\n";
}else{
    print "no match" . "\n";    # こちらが表示される
}
```

---

## 練習問題

1. 正規表現 `p.l` に合致する文字列をすべて選んでください

    1. perl
    2. pl
    3. pal

1. 正規表現 `p.*l` に合致する文字列をすべて選んでください

    1. perl
    2. pl
    3. pal

1. 正規表現 `p.+l` に合致する文字列をすべて選んでください

    1. perl
    2. pl
    3. pal


---

## 練習問題

1. 正規表現 `[perl]?` に合致する文字列をすべて選んでください

    1. go
    1. perl
    1. ruby

1. 正規表現 `[perl]*` に合致する文字列をすべて選んでください

    1. go
    1. perl
    1. ruby

1. 正規表現 `[perl]+` に合致する文字列をすべて選んでください

    1. go
    1. perl
    1. ruby

---

## 文字を表す文字、メタ文字（2/3）

| メタ文字 | 説明 |
| - | - |
| `(●)` | グループを作る。正規表現 `●` にマッチした場合、キャプチャを行う
| `(?:●)` | グループを作るが、キャプチャは行わない
| `●*?` | `●*` と同じ意味だが、マッチパターンが複数ある場合、 `●*` はなるべく長くマッチするのに対し、 `●*?` はなるべく短くマッチする
| `●\|◎` | 左右の正規表現 `●◎` のどちらかにマッチする


---

## `(●)` でグループを作ってキャプチャする

正規表現 `●` を `()` で囲むことで、マッチした文字列を取得することができます。これを **キャプチャ** と呼びます。

キャプチャされた文字列は `$1` という特殊変数に格納されます。この `$1` は `my` で宣言せずに利用します。

```perl
if ('perl girl' =~ /(p..l)/){
    print $1 . "\n";    # perl girl
}else{
    print "no match" . "\n";
}
```

---

## `(●)` でグループを作ってキャプチャする

複数キャプチャすることも可能で、そのときはマッチした文字列が $1, $2 ... と順番に変数に格納されます。

複数キャプチャする時はこのようになります。

```perl
if ('perl girl' =~ /(p..l) (g..l)/){
    print $1 . "\n";    # perl
    print $2 . "\n";    # girl
}else{
    print "no match" . "\n";
}
```

---

## `(?:●)` でグループを作るがキャプチャしない

取得したい文字列が決まっているが、それとは別にグループだけしておきたいという場面が出てきます。

例えば以下の例で `girl` だけ取得したい場合、2 回キャプチャして 2 回目のみを利用するだけでも用は足ります。

しかし、利用されなかった `$1` はどこかで利用する？という疑問がプログラム上に残ります。

```perl
if ('perl girl' =~ /(p..l) (g..l)/){
    # $2 だけでも目的は果たせるが、$1 はどこかで利用する？という疑問が残る
    print $2 . "\n";    # girl
}else{
    print "no match" . "\n";
}
```

---

## `(?:●)` でグループを作るがキャプチャしない

このような場合には「キャプチャしないグループ化」である `(?:●)` を利用します。

これにより、格納する変数をシンプルにし、どこをキャプチャしたいのかをプログラム上で明確にすることができます。

```perl
if ('perl girl' =~ /(?:p..l) (g..l)/){
    # 最初のグループ化をキャプチャしない、という意図をコード上で明確にする
    print $1 . "\n";    # girl
}else{
    print "no match" . "\n";
}
```

---

## メタ文字 `●*?` 怠惰なマッチ

`*` に合致する正規表現 ● があった場合、できるだけ長い文字列を取得します。これを Greedy mach 強欲なマッチとも呼びます。

先にあげた例がまさに強欲なマッチの例です。

```perl
if ('perl girl' =~ /(p.*rl)/){
    print $1 . "\n";    # perl girl
}else{
    print "no match" . "\n";
}
```

これに対し、合致するできるだけ短い文字列を取得する動作が lazy match 怠惰なマッチです。

```perl
if ('perl perfect girl' =~ /(p.*?rl)/){
    print $1 . "\n";    # perl
}else{
    print "no match" . "\n";
}
```

---

## メタ文字 `●|◎` 左右の正規表現 `●◎` のどちらかにマッチする

<ruby>`|`<rt>バー</rt></ruby> で区切られた、左右にある正規表現のどちらかにマッチするか判定します。


```perl
if ('perl' =~ /r.by|p.rl/){
    print "match" . "\n";   # こちらが表示される
}else{
    print "no match" . "\n";
}
```

---

## メタ文字 `●|◎` 左右の正規表現 `●◎` のどちらかにマッチする

`()` と組み合わせて、マッチした文字列をキャプチャする方法がよくとられます。

```perl
if ('perl' =~ /(r.by|p.rl)/){
    print $1 . "\n";    # perl
}else{
    print "no match" . "\n";
}
```

---

## 練習問題（考え中）

以下についての問題

```
| (●) | グループを作る。正規表現 ● にマッチした場合、キャプチャを行う
| (?:●) | グループを作るが、キャプチャは行わない
| ●*? | ●* と同じ意味だが、マッチパターンが複数ある場合、 ●* はなるべく長くマッチするのに対し、 ●*? はなるべく短くマッチする
| ●\|◎ | 左右の正規表現 ●◎ のどちらかにマッチする
```

---

## 文字を表す文字、メタ文字（3/3）

| メタ文字 | 説明 |
| - | - |
| `^●` | 正規表現 `●` の冒頭にある場合、文字列の冒頭でのみマッチする
| `●$` | 正規表現 `●` の末尾にある場合、文字列の末尾でのみマッチする
| `\s` | 空白、改行、タブのうち 1 文字を表す
| `\d` | 数字 1 文字を表す
| `\b` | 単語境界

---

## メタ文字 `^` 正規表現が冒頭にある場合のみマッチする

正規表現の位置によって、マッチするかどうかを判定することも可能です。まずは冒頭からです。

```perl
if ('perl' =~ /^r/){    # 冒頭に r があるか？
    print "match" . "\n";
}else{
    print "no match" . "\n";   # こちらが表示される
}
```

```perl
if ('ruby' =~ /^r/){
    print "match" . "\n";   # こちらが表示される
}else{
    print "no match" . "\n";
}
```

---

## メタ文字 `^` 正規表現が冒頭にある場合のみマッチする

この `^` は、文字クラス `[ ]` の中にあると否定の意味になることは先に紹介しました。

複雑な条件を限られた記号で表す必要があるため、同じ記号でも使われる場所によって意味が異なってきます。

最初は混乱すると思うのですが、使っていると慣れて判別がつくようになります。

---

## メタ文字 `$` 正規表現が末尾にある場合のみマッチする

位置による正規表現マッチ、次は末尾です。

```perl
if ('perl' =~ /l$/){
    print "match" . "\n";   # こちらが表示される
}else{
    print "no match" . "\n";
}
```

```perl
if ('ruby' =~ /l$/){
    print "match" . "\n";
}else{
    print "no match" . "\n";   # こちらが表示される
}
```

---

## メタ文字 `\s` 空白、改行、タブのうち 1 文字を表す

文字の種別によるマッチです。`\s` は空白を表すメタ文字です。

```perl
if ('perl girl' =~ /(?:.+rl)\s(?:.+rl)/){   # 空白 1 つ
    print "match" . "\n";   # こちらが表示される
}else{
    print "no match" . "\n";
}
```

```perl
if ('perl          girl' =~ /(?:.+rl)\s+(?:.+rl)/){ # 複数の空白
    print "match" . "\n";   # こちらが表示される
}else{
    print "no match" . "\n";
}
```

---

## メタ文字 `\d` 数字 1 文字を表す

```perl
if ('perl 5' =~ /perl \d/){
    print "match" . "\n";   # こちらが表示される
}else{
    print "no match" . "\n";
}
```

```perl
if ('2021' =~ /\d\d\d\d/){
    print "match" . "\n";   # こちらが表示される
}else{
    print "no match" . "\n";
}
```

---

## メタ文字 `\b` 単語境界を表す

単語境界とは「文字列の先頭」「文字列と文字列の間」「文字列の最後」のことを言います。

```perl
if ('hello perl' =~ /\bperl\b/){
    print "match" . "\n";   # こちらが表示される
}else{
    print "no match" . "\n";
}
```

```perl
if ('hello perlmonger' =~ /\bperl\b/){
    print "match" . "\n";
}else{
    print "no match" . "\n";   # こちらが表示される
}
```

---

## 量指定子 `●{n}` n回の正規表現の繰り返し

`?`, `*`, `+` といった 0 回, 1 回, 1 回以上といった指定の他に、柔軟に正規表現の繰り返しを指定する方法があります。

それが量指定子です。　

例えば、2021-09-25 のような文字列は以下のようにマッチさせることができますが、記述が冗長です。

```perl
if ( '2021-09-25' =~ /\d\d\d\d-\d\d-\d\d/ ) {
    print "ok";
}
```

---

## 量指定子 `●{n}` n回の正規表現の繰り返し

あらかじめ繰り返しの数がわかっている場合には、量指定子 `{n}` を利用すると見やすく記述することができます。

```perl
if ( '2021-09-25' =~ /\d{4}-\d{2}-\d{2}/ ) {
    print "ok";
}
```

量指定子は以下のような繰り返し回数の指定も可能です。

-  `●{n,}`

    n回以上の正規表現の繰り返し

- `●{n,m}`

    n回以上、m回以下の正規表現の繰り返し

---

## 練習問題（考え中）

```
| ^● | 正規表現 ● の冒頭にある場合、文字列の冒頭でのみマッチする
| ●$ | 正規表現 ● の末尾にある場合、文字列の末尾でのみマッチする
| \s | 空白、改行、タブのうち 1 文字を表す
| \d | 数字 1 文字を表す
| \b | 単語境界| \d | 数字 1 文字を表す
```

- 量指定子をつかって、`2021-10-06` にも `2021-1-6` にもマッチする正規表現を作りましょう。

---

## 正規表現を用いた置換

これまでは、正規表現を用いて特定の文字のテスト、マッチ、キャプチャを行ってきました。

さらにマッチした文字列の置換を行うことができます。

```perl
my $greet = "Hello! Alice";
$greet =~ s/Alice/Perl/;

print $greet . "\n";    # Hello! Perl
```

単語境界を用いてこのように書くこともできます。
```perl
my $greet = "Hello! Alice";
$greet =~ s/\bA.+\b/Perl/;

print $greet . "\n";    # Hello! Perl
```

---

## 区切り記法の変更

ファイルの位置を示す <ruby>path<rt>パス</rt></ruby> や url を正規表現で置換する際に、正規表現で用いる区切り文字 `/` と URL の区切り文字である `/` が混在して見難くなる場合があります。

このような場合には、正規表現を囲む区切り文字 `/ /` を変えることができます。

```perl
my $path = '/usr/local/bin/perl';
$path =~ s{/usr/local/bin/}{/usr/bin/}; # { } に変えている

print $path . "\n"; # /usr/bin/perl
```

---

## 区切り記法の変更

置換だけではなく、マッチを探す際にも区切り文字を変更することが可能です。

その場合には `m{●}` と書きます。実はこれまでに学習した `/ /` は `m/ /` の省略形でした。

```perl
if ('perl' =~ m{p..l} ){
    print "match" . "\n";   # こちらが表示される
}else{
    print "no match" . "\n";
}
```

---

## 修飾子

例えば、大文字小文字を問わずに検索したい場合、これまで学習した内容だと文字クラスを使って表すことができます。

```perl
if ('Perl' =~ /[pP][eE][rR][lL]/){
    print "match" . "\n";   # こちらが表示される
}else{
    print "no match" . "\n";
}
```

しかし、もっと簡単に書く方法があります。それが **i 修飾子** です。i 修飾子を使うことで、マッチの際に大文字小文字を区別しなくなります。

```perl
if ('Perl' =~ /perl/i ){    # i修飾子
    print "match" . "\n";   # こちらが表示される
}else{
    print "no match" . "\n";
}
```

---

## エスケープ

正規表現では任意の一文字を表す <ruby>`.`<rt>ドット</rt></ruby> ですが、この <ruby>`.`<rt>ドット</rt></ruby> そのものをマッチや置換対象にしたいときはどうすれば良いでしょう？

ドットの他にも <ruby>`/`<rt>スラッシュ</rt></ruby> や <ruby>`\`<rt>バックスラッシュ</rt></ruby> 、<ruby>`+`<rt>プラス</rt></ruby>、<ruby>`*`<rt>アスタリスク</rt></ruby> 、<ruby>`[ ]`<rt>角かっこ</rt></ruby> など、正規表現中で特別な意味を持つ記号を検索したいときはどうすれば良いでしょう？

---

## エスケープ

そのようなときは <ruby>`\`<rt>バックスラッシュ</rt></ruby> をその記号の前においてください。

```perl
if ('.net' =~ /\.net/ ){     # .
    print "match" . "\n";   # こちらが表示される
}else{
    print "no match" . "\n";
```

バックスラッシュ自体をマッチさせたい時には `\\` のように、バックスラッシュを2回続けて記述します。

```perl
if ('\\\\' =~ /\\+/ ){      # 複数のバックスラッシュ
    print "match" . "\n";   # こちらが表示される
}else{
    print "no match" . "\n";
}
```

このように、その記号がもつ特別な働きを無効にすることを「エスケープする」といいます。

---

## 練習問題（考え中）

```
- 特定の文字を「含まない」

- 2021-09-25 といった、4桁の数字, ハイフン, 2桁の数字, ハイフン, 2桁の数字を連結したもの

- 行頭に「メロス」が存在する行のみ

```

---

## ここまでが正規表現入門

駆け足で正規表現について学習してきました。

正規表現はプログラムの中だけではなく、テキストエディタや Everything（Windows）などの検索ツールでも利用が可能です。

特定の文字列を抜き出したい、曖昧な条件の単語を置き換えたい、という場面は意外に多いものです。

少なくとも、正規表現というものがあり、それを使えばうまいこと文字列処理をやれる。正規表現といえば Perl ！ ということを知っているだけでも大きいです。

---

## 更なる正規表現の学習へ

例えば、「東京都」と「京都」という文字列が与えられた時に、京都にのみマッチさせるにはどのような正規表現を使えば良いでしょう？

```perl
use utf8;
my @cities = ( '京都', '東京都' );
for my $city (@cities) {
    if ( $city =~ /京都/ ) {
       print $city . "\n";  # 京都 も 東京都 も表示されてしまう
    }
}
```

---

## 更なる正規表現の学習へ

このような場合には「否定の<ruby>後読<rt>あとよ</rt></ruby>み」を使うことで 京都 のみマッチさせることが可能です。

```perl
use utf8;
my @cities = ( '京都', '東京都' );
for my $city (@cities) {
    if ( $city =~ /(?<!東)京都/ ) {    # 京都 のみ表示される。否定の後読み
        print $city . "\n";
    }
}
```

---

## 更なる正規表現の学習へ

今回の講義資料については、以下の Web+DB Press vol.113 の Perl Hackers Hub の記事を参考にしています。

先に紹介した「否定の後読み」などについても解説があります。ぜひ見てください。

第58回　正規表現の勘所―わかりづらい記法の覚え方，先読みや後読みの実践（1）：Perl Hackers Hub｜gihyo.jp … 技術評論社
https://gihyo.jp/dev/serial/01/perl-hackers-hub/005801


---

## 出来た方は、Discord のテキストチャットで「出来た！」とリアクションお願いします！

---

## 休憩 ＆ 質問 ＆ 雑談 タイム<br>（5 〜 10 分）


---

## お疲れ様でした!

サポーターや参加者の皆さんと交流しましょう。

不明点は Discord #雑談部屋 で是非質問してください。

「●●をやりたいが、何から手をつけていいかわからない」といった質問にも、何かしらアドバイスやヒントを提供できる場になればと考えています。

次回以降の参加もお待ちしております!


---

